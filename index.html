<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>C42 Flight Buddy</title>
  <style>
    /* same CSS as before — omitted for brevity */
  </style>
</head>
<body>
  <h1>C42 Flight Buddy</h1>
  <button id="toggle-theme">Dark Mode</button>
  <p><em>Version: 2.0</em></p>
  <p>Check flight weather at Swansea Airport</p>

  <label for="start">Flight Start (GMT):</label>
  <input type="datetime-local" id="start" />

  <label for="duration">Flight Duration (hours):</label>
  <input type="number" id="duration" min="0.5" step="0.5" value="1" />

  <div id="results"></div>

  <footer>
    &copy; 2025 Richard Ball. All rights reserved.
  </footer>

<script>
const LAT = 51.605;
const LON = -4.064;
const OWM_KEY = '81a0d8bef1288c6437560f89b336dd33';
const METEOSOURCE_KEY = 'mpwturrttqmcb4ax95xo94feri15h24bzcj6736m';
const elevation = 295;

// === Shared helper functions (same as original) ===
// estimateDewPoint, estimateCloudBase, highlight, predictRunway,
// checkLimits, icingRisk, shearRisk, turbulenceRisk, formatUKDate
// These functions remain unchanged and are omitted for brevity.
// Please copy them from your original code above — they stay the same.

async function fetchOpenWeatherData() {
  const res = await fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${LAT}&lon=${LON}&appid=${OWM_KEY}&units=metric`);
  return res.json();
}

async function fetchMeteosourceData() {
  const res = await fetch(`https://www.meteosource.com/api/v1/free/point?place_id=swansea&sections=hourly&timezone=UTC&language=en&units=metric&key=${METEOSOURCE_KEY}`);
  return res.json();
}

function findClosestForecast(forecasts, targetTime) {
  return forecasts.reduce((closest, current) => {
    const currentDiff = Math.abs(new Date(current.dt * 1000) - targetTime);
    const closestDiff = Math.abs(new Date(closest.dt * 1000) - targetTime);
    return currentDiff < closestDiff ? current : closest;
  });
}

function findClosestMeteosource(hourlies, targetTime) {
  return hourlies.reduce((closest, current) => {
    const currentTime = new Date(current.date);
    const closestTime = new Date(closest.date);
    const currentDiff = Math.abs(currentTime - targetTime);
    const closestDiff = Math.abs(closestTime - targetTime);
    return currentDiff < closestDiff ? current : closest;
  });
}

async function checkFlight() {
  const startInput = document.getElementById("start").value;
  const duration = parseFloat(document.getElementById("duration").value);
  const resDiv = document.getElementById("results");

  if (!startInput || isNaN(duration) || duration <= 0) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration.</p>';
    return;
  }

  const startTime = new Date(startInput + "Z");
  const endTime = new Date(startTime.getTime() + duration * 3600 * 1000);
  const now = new Date();
  const maxForecastTime = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000);

  if (startTime <= now || startTime > maxForecastTime || endTime > maxForecastTime) {
    resDiv.innerHTML = '<p class="bad">Please enter a valid start time and duration within the next 5 days.</p>';
    return;
  }

  resDiv.innerHTML = '<p>Loading weather data...</p>';

  try {
    const [owm, meteo] = await Promise.all([fetchOpenWeatherData(), fetchMeteosourceData()]);

    const hourlyMeteo = meteo.hourly.data;
    let messages = [];

    const allForecastTimes = owm.list.filter(f => {
      const t = new Date(f.dt * 1000);
      return t >= startTime && t <= endTime;
    });

    if (!allForecastTimes.length) {
      resDiv.innerHTML = '<p class="bad">No matching forecast intervals.</p>';
      return;
    }

    for (const owmPoint of allForecastTimes) {
      const forecastTime = new Date(owmPoint.dt * 1000);
      const meteoPoint = findClosestMeteosource(hourlyMeteo, forecastTime);

      // Extract values
      const temp = Math.min(owmPoint.main.temp, meteoPoint.temperature);
      const humidity = Math.max(owmPoint.main.humidity, meteoPoint.relative_humidity);
      const pressure = Math.min(owmPoint.main.pressure, meteoPoint.sea_level_pressure || 1013);
      const windSpeed = Math.max(owmPoint.wind.speed, meteoPoint.wind.speed) * 1.94384; // to knots
      const gustSpeed = Math.max(owmPoint.wind.gust || 0, meteoPoint.wind.gust || 0) * 1.94384;
      const windDeg = owmPoint.wind.deg; // use OpenWeatherMap's for runway
      const cloudCover = Math.max(owmPoint.clouds.all, meteoPoint.cloud_cover);
      const visibility = Math.min(owmPoint.visibility || 10000, meteoPoint.visibility || 10000);
      const weatherDesc = owmPoint.weather[0].description || meteoPoint.weather;

      // Calculated values
      const dewPoint = estimateDewPoint(temp, humidity);
      const cloudBase = estimateCloudBase(temp, dewPoint);
      const QFE = (pressure - (elevation * 0.12)).toFixed(1);
      const windKts = +(windSpeed).toFixed(1);
      const gustKts = +(gustSpeed).toFixed(1);
      const runway = predictRunway(windDeg);
      const safe = checkLimits(windKts, gustKts, visibility, weatherDesc, cloudCover, cloudBase);
      const icing = icingRisk(temp, dewPoint);
      const shear = shearRisk(windKts, gustKts);
      const turb = turbulenceRisk(gustKts);

      let visClass = "";
      if (visibility < 3000) visClass = "bad";
      else if (visibility < 5000) visClass = "warn";
      const visDisplay = visibility > 5000 ? '>5000 m' : `<span class="${visClass} highlight">${visibility} m</span>`;

      const rainLevel = (() => {
        const descLower = weatherDesc.toLowerCase();
        if (!descLower.includes('rain')) return 'none';
        if (descLower.includes('light') && cloudCover < 99) return 'warn';
        return 'bad';
      })();
      const rainClass = rainLevel === 'bad' ? 'bad' : rainLevel === 'warn' ? 'warn' : '';

      messages.push(
`Time: ${formatUKDate(forecastTime)}
Temperature: ${temp.toFixed(1)}°C
${highlight("Cloud base: ~", cloudBase + " ft AGL", cloudBase < 1000, "bad")}
QNH: ${pressure} hPa
QFE: ${QFE} hPa
${highlight("Wind: ", windDeg + "° @ " + windKts + " kt", windKts > 20)}
${highlight("Gusts: ", gustKts + " kt", gustKts > 20)}
Visibility: ${visDisplay}
Cloud cover: ${cloudCover} %
Weather: <span class="${rainClass} highlight">${weatherDesc}</span>
Icing Risk: ${icing === 'Risk' ? `<span class="bad highlight">${icing}</span>` : icing}
Wind Shear Risk: <span class="${shear.class}">${shear.level}</span>
Turbulence Risk: <span class="${turb.class}">${turb.level}</span>
Predicted Runway: ${runway}
${highlight("Status: ", safe.safe ? "✅ OK" : "❌ Limit Exceeded", !safe.safe)}\n`
      );
    }

    const anyBad = messages.some(msg => msg.includes("❌") || msg.includes("bad highlight"));

    const overallStatus = anyBad
      ? '<p class="bad"><strong>❌ Weather issues detected during flight.</strong></p>'
      : '<p class="ok"><strong>✅ Weather suitable for full flight duration.</strong></p>';

    resDiv.innerHTML = 
      `<h3>Flight Weather Check for ${formatUKDate(startTime)} to ${formatUKDate(endTime)}</h3>
      <pre>${messages.join("\n")}</pre>
      ${overallStatus}`;
  } catch (e) {
    resDiv.innerHTML = '<p class="bad">Error fetching weather data.</p>';
    console.error(e);
  }
}

window.addEventListener('load', () => {
  const now = new Date();
  now.setUTCMinutes(0,0,0);
  now.setUTCHours(now.getUTCHours() + 1);
  const isoString = now.toISOString().slice(0,16);
  document.getElementById("start").value = isoString;
  document.getElementById("duration").value = 1;
  checkFlight();

  const toggleBtn = document.getElementById('toggle-theme');
  const body = document.body;
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'dark') {
    body.classList.add('dark-mode');
    toggleBtn.textContent = 'Light Mode';
  }
  toggleBtn.addEventListener('click', () => {
    body.classList.toggle('dark-mode');
    toggleBtn.textContent = body.classList.contains('dark-mode') ? 'Light Mode' : 'Dark Mode';
    localStorage.setItem('theme', body.classList.contains('dark-mode') ? 'dark' : 'light');
  });
});

document.getElementById("start").addEventListener("change", checkFlight);
document.getElementById("duration").addEventListener("input", checkFlight);
</script>
</body>
</html>
